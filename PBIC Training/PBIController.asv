function [T] = PBIController(z,p,x_m,xd_m,x_0,xd_0,dt_phy)
%Controller that uses PB-IC to calculate the torque needed
%dt_phy: time step of the physical system
%x_m,xd_m: previous impedance model va
th1 = z(1);
th2 = z(3);
thdot1 = z(2);
thdot2 = z(4);

J = Velocity_transformation(p.l1,p.l2,th1,th2); % J  =Jacobian
J_dt = Jdt(p.l1,p.l2,th1,th2,thdot1,thdot2);
H=[p.I1 0;0 p.I2;];

F_int = [p.Fx, p.Fy];
K = p.K; % K stiffness for impedance model
B = p.B; % B damping for impedance model
M= p.M; % M inertia for impedance model


% intergration for the desired model
%%%% INTEGRATION %%%%%%%%%
%Old velocity and position
x_m = [x_m(1), x_m(2)];
xd_m = [xd_m(1), xd_m(2)];

xdd_m = (K*(x_0 - x_m) + B*(xd_0 - xd_m) - F_int)/M;

%Update x,v,a
ainter = [xdd_m(1), xdd_m(2)];
vinter = xd_m + ainter*dt_phy; %Update velocity based on old RHS call

x_m = x_m + vinter*dt_phy;
%%%%%%%%%%%%%%%%%%%%
    
 
[q1_d, q2_d] = InverseKin(p.l1, p.l2, x_m(1), x_m(2)); % joint value desired  
solution_select = 1; % TODO: write a code that select the inverseK solution set
q_d = [q1_d(solution_select)-pi/2, q2_d(solution_select)];
qdt_d = pinv(J)*[xd_m(1) xd_m(2) 0]';% joint value desired derivative 
qddt_d =pinv(J)*[xdd_m(1) xdd_m(2) 0]'+J_dt'*[xd_m(1) xd_m(2) 0]';% joint value desired second derivative 


% Torque to track our desired point
T = H*(qddt_d+p.Kd*(qdt_d'-[thdot1 thdot2]')+p.Kp*(q_d'-[th1 th2]'));
T = T+ -J'*[p.Fx; p.Fy;0];

% Add gravity compensation , h(q)
T(1) = T(1) + GravityCompT1(0,0,p.d1,p.d2,p.g,p.l1,p.l2,p.m1,p.m2,th1,th2,thdot1,thdot2);
T(2) = T(2) + GravityCompT2(0,0,p.d2,p.g,p.l1,p.l2,p.m2,th1,th2,thdot1);


end